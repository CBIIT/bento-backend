# Indices settings
Indices:
  # First index
  # Name of the index to be created, existing index with same name will be deleted
  - index_name: cases
    type: neo4j
    # type mapping for each property of the index

    mapping:
      # properties used as facet filters (can be also used to return data), name matches GraphQL parameter names
      program:
        type: keyword
      study_code:
        type: keyword
      #        TODO TOBE DELETED
      study:
        type: keyword
      study_type:
        type: keyword
      biobank:
        type: keyword
      breed:
        type: keyword
      diagnosis:
        type: keyword
      disease_site:
        type: keyword
      stage_of_disease:
        type: keyword
      response_to_treatment:
        type: keyword
      sex:
        type: keyword
      neutered_status:
        type: keyword
      case_id:
        type: keyword
      # TODO To Be DEELTED
      case_ids:
        type: keyword
      # properties used in return data, name can be different from GraphQL property name
      cohort:
        type: keyword
      age:
        type: float
      weight:
        type: float
      files:
        type: keyword
      other_cases:
        type: keyword
      individual_id:
        type: keyword
      primary_disease_site:
        type: keyword
      date_of_diagnosis:
        type: keyword
      histology_cytopathology:
        type: keyword
      histological_grade:
        type: keyword
      pathology_report:
        type: keyword
      treatment_data:
        type: keyword
      follow_up_data:
        type: keyword
      concurrent_disease:
        type: keyword
      concurrent_disease_type:
        type: keyword
      arm:
        type: keyword
      study_participation:
        type: keyword
      clinical_study_designation:
        type: keyword
      study_files:
        type: keyword
      sample_site:
        type: keyword
      sample_type:
        type: keyword
      sample_pathology:
        type: keyword
      file_association:
        type: keyword
      file_type:
        type: keyword
      file_format:
        type: keyword
      program_info:
        type: nested
        properties:
          # TODO TOBE DELETED
          program:
            type: keyword
          program_acronym:
            type: keyword
      samples_info:
        type: nested
        properties:
          sample_id:
            type: keyword
          #          TODO TO BE DELETED
          sample_ids:
            type: keyword
          sample_site:
            type: keyword
          sample_type:
            type: keyword
          sample_pathology:
            type: keyword
          tumor_grade:
            type: keyword
          sample_chronology:
            type: keyword
          percentage_tumor:
            type: keyword
          necropsy_sample:
            type: keyword
          sample_preservation:
            type: keyword
          physical_sample_type:
            type: keyword
          general_sample_pathology:
            type: keyword
          tumor_sample_origin:
            type: keyword
          comment:
            type: keyword
      # TODO DELETE
      files_info:
        type: nested
        properties:
          file_uuid:
            type: keyword
          file_uuids:
            type: keyword
          file_size:
            type: double
          file_format:
            type: keyword
          file_description:
            type: keyword
          file_name:
            type: keyword
          file_type:
            type: keyword
          file_association:
            type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (c:case)
      OPTIONAL MATCH (r:registration)-->(c)-->(sty:study)
      WHERE NOT r.registration_origin = sty.clinical_study_designation
      WITH DISTINCT c, COLLECT(DISTINCT c.case_id) as biobank_cases,r
      OPTIONAL MATCH (c)-->(i:canine_individual)<--(o:case)
      OPTIONAL MATCH (s:study)<--(c)
      OPTIONAL MATCH (reg:registration)-->(c)
      OPTIONAL MATCH (c)-->(ss:study)<--(ff:file)
      OPTIONAL MATCH (c)<--(demo:demographic)
      OPTIONAL MATCH (c)<--(diag:diagnosis)
      OPTIONAL MATCH (c)-->(co:cohort)
      OPTIONAL MATCH (f:file)-[*]->(c)
      OPTIONAL MATCH (parent)<--(f:file)
      OPTIONAL MATCH (co)-->(a:study_arm)
      OPTIONAL MATCH (c)-->(ci:canine_individual)
      OPTIONAL MATCH (ss:study)<-[:member_of]-(c)  
      OPTIONAL MATCH (p:program)<--(s:study)<--(c)
      OPTIONAL MATCH (c)<--(samp:sample)
      WITH DISTINCT c, s, a, co, demo, diag, f, o, i, ci,p,samp,ff,parent,biobank_cases,r
      return
        c.case_id AS case_id,
        c.case_id AS case_ids,
        CASE c.case_id IN biobank_cases and NOT r.registration_origin = s.clinical_study_designation WHEN True THEN COLLECT(DISTINCT r.registration_origin) ELSE 'Not Applicable' END AS biobank,
        (s.clinical_study_designation + '(' + s.accession_id +')') AS study_code,        
        (s.clinical_study_designation + '(' + s.accession_id +')') AS study,        
        s.clinical_study_type AS study_type,
        co.cohort_description AS cohort,
        demo.breed AS breed,
        diag.disease_term AS diagnosis,
        diag.stage_of_disease AS stage_of_disease,
        demo.patient_age_at_enrollment AS age,
        demo.sex AS sex,
        demo.neutered_indicator AS neutered_status,
        demo.weight AS weight,
        diag.best_response AS response_to_treatment,
        diag.primary_disease_site as disease_site,
        collect(DISTINCT o.case_id) AS other_cases,
        i.canine_individual_id as individual_id,
        diag.primary_disease_site as primary_disease_site,
        diag.date_of_diagnosis as date_of_diagnosis,
        diag.histology_cytopathology as histology_cytopathology,
        diag.histological_grade as histological_grade,
        diag.pathology_report as pathology_report,
        diag.treatment_data as treatment_data,
        diag.follow_up_data as follow_up_data,
        diag.concurrent_disease as concurrent_disease,
        diag.concurrent_disease_type as concurrent_disease_type,
        a.arm as arm,
        COLLECT(DISTINCT(samp.sample_site)) AS sample_site,
        COLLECT(DISTINCT(samp.summarized_sample_type)) AS sample_type,
        COLLECT(DISTINCT(samp.specific_sample_pathology)) AS sample_pathology,
        CASE head(labels(parent)) WHEN 'study' THEN 'study' ELSE 'other' END AS file_association,
        COLLECT(DISTINCT(f.file_type)) AS file_type,
        COLLECT(DISTINCT(f.file_format)) AS file_format,
        COLLECT(DISTINCT (ff.uuid)) AS study_files,
        COLLECT(DISTINCT(f.uuid)) AS files,
        CASE ci IS NULL WHEN True THEN 'Single Study' ELSE 'Multiple Study' END AS study_participation,
        s.clinical_study_designation as clinical_study_designation,
        COLLECT(DISTINCT p.program_acronym) AS program,        
        COLLECT(DISTINCT {program_acronym: p.program_acronym,program:p.program_acronym}) AS program_info,
        COLLECT(DISTINCT {sample_id: samp.sample_id,
                          sample_ids: samp.sample_id,
                          sample_site: samp.sample_site,
                          sample_type: samp.summarized_sample_type,
                          sample_pathology:samp.specific_sample_pathology,
                          tumor_grade: samp.tumor_grade,
                          sample_chronology: samp.sample_chronology,
                          percentage_tumor: samp.percentage_tumor,
                          necropsy_sample: samp.necropsy_sample,
                          sample_preservation: samp.sample_preservation,
                          physical_sample_type: samp.physical_sample_type,
                          general_sample_pathology:samp.general_sample_pathology,
                          tumor_sample_origin:samp.tumor_sample_origin,
                          comment:samp.comment}) AS samples_info,
        COLLECT(DISTINCT {file_uuid: f.uuid,
                  file_uuids: f.uuid,
                  file_association: head(labels(parent)),
                  file_size: f.file_size,
                  file_format: f.file_format,
                  file_description: f.file_description,
                  file_name: f.file_name,
                  file_type: f.file_type}) AS files_info
      "
  - index_name: samples
    type: neo4j
    # type mapping for each property of the index

    mapping:
      # properties used in list search, could also used in return data
      # TODO To Be Deleted
      case_id:
        type: keyword
      case_ids:
        type: keyword
      # TODO To Be Deleted
      sample_id:
        type: keyword
      sample_ids:
        type: keyword
      # properties used in return data, name can be different from GraphQL property name
      breed:
        type: keyword
      diagnosis:
        type: keyword
      sample_site:
        type: keyword
      sample_type:
        type: keyword
      sample_pathology:
        type: keyword
      tumor_grade:
        type: keyword
      sample_chronology:
        type: keyword
      percentage_tumor:
        type: keyword
      necropsy_sample:
        type: keyword
      sample_preservation:
        type: keyword
      files:
        type: keyword
      physical_sample_type:
        type: keyword
      general_sample_pathology:
        type: keyword
      tumor_sample_origin:
        type: keyword
      comment:
        type: keyword
      individual_id:
        type: keyword
      other_cases:
        type: keyword
      patient_age_at_enrollment:
        type: keyword
      sex:
        type: keyword
      neutered_indicator:
        type: keyword
      weight:
        type: keyword
      primary_disease_site:
        type: keyword
      stage_of_disease:
        type: keyword
      date_of_diagnosis:
        type: keyword
      histology_cytopathology:
        type: keyword
      histological_grade:
        type: keyword
      best_response:
        type: keyword
      pathology_report:
        type: keyword
      treatment_data:
        type: keyword
      follow_up_data:
        type: keyword
      concurrent_disease:
        type: keyword
      concurrent_disease_type:
        type: keyword
      cohort_description:
        type: keyword
      arm:
        type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (s:sample)
      OPTIONAL MATCH (s)-[:of_case]->(c:case)
      OPTIONAL MATCH (c)<-[:of_case]-(demo:demographic)
      OPTIONAL MATCH (c)<-[:of_case]-(d:diagnosis)
      OPTIONAL MATCH (f:file)-[:of_sample]->(s)
      OPTIONAL MATCH (c)-->(i:canine_individual)<--(o:case)
      OPTIONAL MATCH (c)-->(co:cohort)
      OPTIONAL MATCH (co)-->(a:study_arm)
      RETURN DISTINCT
        s.sample_id as sample_id,
        s.sample_id as sample_ids,
        c.case_id as case_id,
        c.case_id as case_ids,
        demo.breed as breed,
        d.disease_term as diagnosis,
        s.sample_site as sample_site,
        s.summarized_sample_type as sample_type,
        s.specific_sample_pathology as sample_pathology,
        s.tumor_grade as tumor_grade,
        s.sample_chronology as sample_chronology,
        s.percentage_tumor as percentage_tumor,
        s.necropsy_sample as necropsy_sample,
        s.sample_preservation as sample_preservation,
        collect(DISTINCT(f.uuid)) AS files,
        s.physical_sample_type as physical_sample_type,
        s.general_sample_pathology as general_sample_pathology,
        s.tumor_sample_origin as tumor_sample_origin,
        s.comment as comment,
        i.individual_id AS individual_id,
        collect(DISTINCT o.case_id) AS other_cases,
        demo.patient_age_at_enrollment AS patient_age_at_enrollment,
        demo.sex AS sex,
        demo.neutered_indicator AS neutered_indicator,
        demo.weight as weight,
        d.primary_disease_site as primary_disease_site,
        d.stage_of_disease as stage_of_disease,
        d.date_of_diagnosis as date_of_diagnosis,
        d.histology_cytopathology as histology_cytopathology,
        d.histological_grade as histological_grade,
        d.best_response as best_response,
        d.pathology_report as pathology_report,
        d.treatment_data as treatment_data,
        d.follow_up_data as follow_up_data,
        d.concurrent_disease as concurrent_disease,
        d.concurrent_disease_type as concurrent_disease_type,
        co.cohort_description as cohort_description,
        a.arm as arm
    "
  - index_name: files
    type: neo4j
    # type mapping for each property of the index

    mapping:
      program:
        type: keyword
      # properties used in list search, could also used in return data
      case_id:
        type: keyword
      case_ids:
        type: keyword
      sample_ids:
        type: keyword
      #      TODO Added
      sample_id:
        type: keyword
      md5sum:
        type: keyword
      file_uuids:
        type: keyword
      #      TODO TO BE DELETED DUPLICATE
      file_uuid:
        type: keyword
      #      TODO TO BE DELETED DUPLICATE
      uuids:
        type: keyword
      #      TODO TO BE DELETED DUPLICATE
      association:
        type: keyword
      file_association:
        type: keyword

      # properties used in return data, name can be different from GraphQL property name
      #      parent_type:
      #        type: keyword
      file_name:
        type: keyword
      file_type:
        type: keyword
      file_description:
        type: keyword
      file_format:
        type: keyword
      file_size:
        type: double
      breed:
        type: keyword
      diagnosis:
        type: keyword
      study_code:
        type: keyword
      #        TODO Duplicate Field
      study:
        type: keyword
      study_type:
        type: keyword
      study_participation:
        type: keyword
      study_files:
        type: keyword
      sample_site:
        type: keyword
      physical_sample_type:
        type: keyword
      general_sample_pathology:
        type: keyword
      tumor_sample_origin:
        type: keyword
      sample_type:
        type: keyword
      sample_pathology:
        type: keyword
      date_of_sample_collection:
        type: keyword
      tumor_grade:
        type: keyword
      sample_chronology:
        type: keyword
      percentage_tumor:
        type: keyword
      necropsy_sample:
        type: keyword
      sample_preservation:
        type: keyword
      comment:
        type: keyword
      individual_id:
        type: keyword
      patient_age_at_enrollment:
        type: keyword
      sex:
        type: keyword
      neutered_indicator:
        type: keyword
      weight:
        type: keyword
      disease_site:
        type: keyword
      stage_of_disease:
        type: keyword
      date_of_diagnosis:
        type: keyword
      histology_cytopathology:
        type: keyword
      neutered_status:
        type: keyword
      response_to_treatment:
        type: keyword
      histological_grade:
        type: keyword
      best_response:
        type: keyword
      pathology_report:
        type: keyword
      treatment_data:
        type: keyword
      follow_up_data:
        type: keyword
      concurrent_disease:
        type: keyword
      concurrent_disease_type:
        type: keyword
      cohort_description:
        type: keyword
      arm:
        type: keyword
      other_cases:
        type: keyword
      biobank:
        type: keyword
      access_file:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (f:file)
      OPTIONAL MATCH (f)-->(parent)
      OPTIONAL MATCH (parent)-[:of_case]->(cf:case)
      OPTIONAL MATCH (r:registration)-->(cf)-->(sty:study)
      WHERE NOT r.registration_origin = sty.clinical_study_designation
      WITH f, parent, CASE cf WHEN NULL THEN parent ELSE cf END AS c,CASE cf WHEN NULL THEN [] ELSE COLLECT(DISTINCT cf.case_id) END AS biobank_cases,r,
      CASE head(labels(parent)) WHEN 'study' THEN 'study' ELSE 'other' END AS association
      OPTIONAL MATCH (c)<-[:of_case]-(demo:demographic)
      OPTIONAL MATCH (c)<-[:of_case]-(diag:diagnosis)
      OPTIONAL MATCH (c)-[:member_of]->(s:study)
      OPTIONAL MATCH (p:program)<--(s)<--(c)
      OPTIONAL MATCH (c)-->(i:canine_individual)<--(o:case)
      OPTIONAL MATCH (f:file)-[*]->(ci:canine_individual)
      OPTIONAL MATCH (f)-[*]->(samp:sample)
      OPTIONAL MATCH (enroll:enrollment)-[:of_case]->(c)
      OPTIONAL MATCH (c)-->(co:cohort)
      OPTIONAL MATCH (co)-->(a:study_arm)
      OPTIONAL MATCH (f)-[*]->(fc:case)
      OPTIONAL MATCH (sp:program)<--(ss:study)<--(f)
      RETURN DISTINCT
        f.file_name as file_name,
        f.file_type as file_type,
        head(labels(parent)) as association,
        association as file_association,
        f.file_description as file_description,
        f.file_format as file_format,
        f.file_size as file_size,
        CASE f.file_size < 12000000 WHEN TRUE THEN 0 ELSE 1 END as access_file,
        f.md5sum as md5sum,
        c.case_id as case_id,
        c.case_id as case_ids,
        demo.breed as breed,
        diag.disease_term as diagnosis,
        diag.best_response AS response_to_treatment,
        CASE head(labels(parent)) WHEN 'study' THEN f.uuid ELSE null END AS study_files,      
        CASE association WHEN 'study' THEN COLLECT(DISTINCT sp.program_acronym) ELSE COLLECT(DISTINCT p.program_acronym) END AS program,       
        CASE WHEN s.clinical_study_designation IS NULL
        THEN (parent.clinical_study_designation + '(' + parent.accession_id +')')
        ELSE (s.clinical_study_designation + '(' + s.accession_id +')') END AS study_code,
        CASE WHEN s.clinical_study_designation IS NULL
        THEN (parent.clinical_study_designation + '(' + parent.accession_id +')')
        ELSE (s.clinical_study_designation + '(' + s.accession_id +')') END AS study,        
        CASE WHEN s.clinical_study_type IS NULL
        THEN parent.clinical_study_type
        ELSE s.clinical_study_type END AS study_type,      
        CASE c.case_id IN biobank_cases and NOT r.registration_origin = s.clinical_study_designation AND r.registration_origin IS NOT NULL WHEN True THEN COLLECT(DISTINCT r.registration_origin) ELSE 'Not Applicable' END AS biobank,
        CASE ci IS NULL WHEN True THEN 'Single Study' ELSE 'Multiple Study' END AS study_participation,        
        f.uuid as file_uuids,
        f.uuid as file_uuid,
        f.uuid as uuids,
        samp.sample_id AS sample_ids,
        samp.sample_id AS sample_id,
        samp.sample_site as sample_site,
        samp.physical_sample_type as physical_sample_type,
        samp.general_sample_pathology as general_sample_pathology,
        samp.tumor_sample_origin as tumor_sample_origin,
        samp.summarized_sample_type as sample_type,
        samp.specific_sample_pathology as sample_pathology,
        samp.date_of_sample_collection as date_of_sample_collection,
        samp.tumor_grade as tumor_grade,
        samp.sample_chronology as sample_chronology,
        samp.percentage_tumor as percentage_tumor,
        samp.necropsy_sample as necropsy_sample,
        samp.sample_preservation as sample_preservation,
        samp.comment as comment,
        ci.canine_individual_id AS individual_id,
        demo.patient_age_at_enrollment as patient_age_at_enrollment,
        demo.neutered_indicator AS neutered_status,    
        demo.sex as sex,
        demo.neutered_indicator as neutered_indicator,
        demo.weight as weight,
        diag.primary_disease_site as disease_site,
        diag.stage_of_disease as stage_of_disease,
        diag.date_of_diagnosis as date_of_diagnosis,
        diag.histology_cytopathology as histology_cytopathology,
        diag.histological_grade as histological_grade,
        diag.best_response as best_response,
        diag.pathology_report as pathology_report,
        diag.treatment_data as treatment_data,
        diag.follow_up_data as follow_up_data,
        diag.concurrent_disease as concurrent_disease,
        diag.concurrent_disease_type as concurrent_disease_type,
        co.cohort_description as cohort_description,
        a.arm as arm,
        collect(DISTINCT o.case_id) AS other_cases
    "
  - index_name: studies
    type: neo4j
    # type mapping for each property of the index
    mapping:
      clinical_study_designation:
        type: keyword
      study_disposition:
        type: keyword
      clinical_study_type:
        type: keyword
      case_ids_case_to_member_of_to_study:
        type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
    MATCH (s:study)
    OPTIONAL MATCH (s:study)<-[:member_of]-(c:case)
    RETURN DISTINCT
      s.clinical_study_designation AS clinical_study_designation,
      s.study_disposition AS study_disposition,
      s.clinical_study_type AS clinical_study_type,
      COLLECT(DISTINCT c.case_id) AS case_ids_case_to_member_of_to_study
    "
  - index_name: diagnosis
    type: neo4j
    # type mapping for each property of the index
    mapping:
      stage_of_disease:
        type: keyword
      primary_disease_site:
        type: keyword
      disease_term:
        type: keyword
      case_id_diag_to_case_of_to_case:
        type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
    MATCH (d:diagnosis)
    OPTIONAL MATCH (d)-[:of_case]->(c:case)
    RETURN DISTINCT
      d.disease_term AS disease_term,
      d.primary_disease_site AS primary_disease_site,
      d.stage_of_disease AS stage_of_disease,
      c.case_id AS case_id_diag_to_case_of_to_case
      "
  - index_name: demographic
    type: neo4j
    # type mapping for each property of the index
    mapping:
      sex:
        type: keyword
      case_id_demogr_to_case_of_to_case:
        type: keyword
      breed:
        type: keyword
      neutered_indicator:
        type: keyword
      patient_age_at_enrollment:
        type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
    MATCH (dg:demographic)
    OPTIONAL MATCH (dg)-[:of_case]->(c:case)
    RETURN DISTINCT
      dg.sex AS sex,
      dg.breed AS breed,
      dg.neutered_indicator AS neutered_indicator,
      dg.patient_age_at_enrollment AS patient_age_at_enrollment,
      dg.case_id AS case_id_demogr_to_case_of_to_case
      "
  - index_name: program
    type: neo4j
    # type mapping for each property of the index
    mapping:
      case_ids_case_to_member_of_member_of_to_p:
        type: keyword
      case_ids_case_to_member_of_member_of_to_p_count:
        type: keyword
      program_acronym:
        type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
    MATCH (p:program)
    OPTIONAL MATCH (p)<-[:member_of]-(s)<-[:member_of]-(c:case)
    RETURN DISTINCT
      p.program_acronym AS program_acronym,
      COLLECT(c.case_id) AS case_ids_case_to_member_of_member_of_to_p,
      count(c.case_id) as case_ids_case_to_member_of_member_of_to_p_count
    "

  - index_name: registration
    type: neo4j
    # type mapping for each property of the index
    mapping:
      registration_origin:
        type: keyword
      case_ids_biobank_cases:
        type: keyword
      biobank_cases_group:
        type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
    MATCH (r:registration)
    OPTIONAL MATCH (r)-->(c:case)-->(s:study)
    WHERE NOT r.registration_origin = s.clinical_study_designation
    WITH COLLECT(DISTINCT c.case_id) as biobank_cases
    MATCH (c:case)-->(s:study)
    OPTIONAL MATCH (r:registration)-->(c)
    WHERE
    (NOT c.case_id IN biobank_cases
    OR NOT r.registration_origin = s.clinical_study_designation)
    WITH c,r,
    CASE c.case_id IN biobank_cases
    WHEN TRUE THEN r.registration_origin
    ELSE 'Not Applicable'
    END AS group
    RETURN 
      r.registration_origin as registration_origin,
      c.case_id as case_ids_biobank_cases,
      group as biobank_cases_group
    "

